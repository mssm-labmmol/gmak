# import base force-field classes
import gmak.runcmd as runcmd
from gmak.parameters import *
from gmak.variations import *
import os
from abc import ABC, abstractmethod, abstractproperty

# Topology Info
# ----------------------------------------------------------------------
# Part of the topology that is not related to the force field, e.g., 
# involving atomic charges, connectivity of the atoms, etc.
# 
# yMHG @ <2021-09-28 ter>:
# I originally wrote this class to allow modifying this part of the topology
# without relying on simple macro-like approaches. However, I ended up not
# using it for anything.

class TopologyInfo:
    def __init__(self, atoms, interPairs, intraPairs, bonds, angles, dihedrals, impropers):
        self.atoms = atoms
        self.interPairs = interPairs
        self.intraPairs = intraPairs
        self.bonds = bonds
        self.angles = angles
        self.dihedrals = dihedrals
        self.impropers = impropers

    def getAtoms(self):
        return [at.asDict() for at in self.atoms]

    def getIntermolecularPairs(self):
        return [pair.asDict() for pair in self.interPairs]

    def getIntramolecularPairs(self):
        return [pair.asDict() for pair in self.intraPairs]

    def getBonds(self):
        return [x.asDict() for x in self.bonds]

    def getAngles(self):
        return [x.asDict() for x in self.angles]

    def getDihedrals(self):
        return [x.asDict() for x in self.dihedrals]

    def getImpropers(self):
        return [x.asDict() for x in self.impropers]

class EmptyTopologyInfo(TopologyInfo):
    def __init__(self):
        super().__init__([], [], [], [], [], [], [])

# Topology
# ----------------------------------------------------------------------
# Full topology, including the ForceField and the TopologyInfo.

class Topology:
    def __init__(self, bondedForcefield, nonbondedForcefield, topoInfo):
        self.bff = bondedForcefield
        self.nbff = nonbondedForcefield
        self.topo = topoInfo

    def updateNonbondedForcefield(self, newNbff):
        self.nbff = newNbff

    def updateBondedForcefield(self, newBff):
        self.bff = newBff

    def getBondtypes(self):
        return self.bff.getBondtypes()

    def getAngletypes(self):
        return self.bff.getAngletypes()

    def getDihedraltypes(self):
        return self.bff.getDihedraltypes()

    def getImpropertypes(self):
        return self.bff.getImpropertypes()

    def getAtomtypes(self):
        return self.nbff.getAtomtypes()

    def getPairtypes(self):
        return self.nbff.getPairtypes()

    def getAtoms(self):
        return self.topo.getAtoms()

    def getIntermolecularPairs(self):
        return self.topo.getIntermolecularPairs()

    def getIntramolecularPairs(self):
        return self.topo.getIntramolecularPairs()

class EmptyTopology(Topology):
    def __init__(self):
        super().__init__(EmptyBondedForcefield(), EmptyNonbondedForcefield(),
                         EmptyTopologyInfo())

# TopologyInput
# ----------------------------------------------------------------------
# This class is responsible to extract a Topology from some objects given
# in initialization.
# 
# yMHG @ <2021-09-28 ter>:
# I ended up not using this class for anything useful because I actually didn't
# need to parse anything regarding topology (only write out things that are
# generated in the program itself). This is why I rely on "DummyTopologyInput"
# all the way.

class AbstractTopologyInput(ABC):

    @abstractmethod
    def getTopology(self, fn):
        pass

class DummyTopologyInput(AbstractTopologyInput):
    def getTopology(self):
        return EmptyTopology()

class GromacsDummyTopologyInput(DummyTopologyInput):
    """This only offers an initialization interface that receives a GROMACS itp
    or top file."""
    def __init__(self, itp_fn):
        pass

# TopologyOutput
# ----------------------------------------------------------------------
# Responsible for writing topology files.

class AbstractTopologyOutput(ABC):

    @abstractmethod
    def writeToFiles(self, topology):
        """Write topology files to the proper files.

        Different topology files are generated by either modifying the topology
        object given or by modifying the path of the output files, which is
        done by an AbstractTopologyOutputSetter concretion.
        """
        pass

    @abstractmethod
    def getFiles(self):
        """Get the path of the output topology files. These paths are controlled
        by an external AbstractTopologyOutputSetter concretion."""
        pass

class GromacsDummyTopologyOutput(AbstractTopologyOutput):

    def __init__(self, itp_input, itp_fn):
        self.fn = itp_fn
        self.itp_input = itp_input

    def _l2z(self, name):
        # TODO More atoms???
        if name[0] == 'X':
            # this is for testing purposes only
            return 1
        if name[0] == 'H':
            return 1
        if name[0] == 'O':
            return 8
        if name[0] == 'C':
            return 6
        if name[0] == 'N':
            return 7
        if name == 'AR':
            return 18

    def _alterFile(self, newFile):
        self.fn = newFile

    def _writeBonded(self, fp, topology):
        fp.write("; placeholder for bondedtypes\n")
        fp.write("\n")

    def _writeNonbonded(self, fp, topology):
        atomtypes = topology.getAtomtypes()
        pairtypes = topology.getPairtypes()
        # Write atomtypes.
        fp.write("[ atomtypes ]\n")
        for label, pars in atomtypes:
            parameters = dict(pars)
            fp.write("%-5s%4d%6.3f%6.3f%3s%18.7e%18.7e\n" % (label, self._l2z(label), 0.0, 0.0, "A",
                                                             parameters['c6'], parameters['c12']))
        fp.write('\n')

        # Write normal pairs.
        fp.write("[ nonbond_params ]\n")
        for label, pars in pairtypes:
            parameters = dict(pars)
            if (label[0] != label[1]):
                fp.write("%-6s%-6s%6d%18.7e%18.7e\n" % (label[0], label[1], 1,
                            parameters['c6'], parameters['c12']))
        fp.write('\n')

        # Write special pairs.
        fp.write("[ pairtypes ]\n")
        for label, pars in pairtypes:
            parameters = dict(pars)
            fp.write("%-6s%-6s%6d%18.7e%18.7e\n" % (label[0], label[1], 1,
                            parameters['cs6'], parameters['cs12']))
        fp.write('\n')

    def _writeTopoInfo(self, fp, topology):
        _fp = open(self.itp_input, 'r')
        for line in _fp:
            fp.write(line)
        _fp.close()

    def getFiles(self):
        return self.fn

    def writeToFiles(self, topology):
        fp = open(self.fn, 'w')

        # Guard force field part.
        fp.write("#ifndef FORCEFIELD_INCLUDE\n")
        fp.write("#define FORCEFIELD_INCLUDE\n")
        # Write defaults block.
        fp.write("[ defaults ]\n; nbfunc        comb-rule       gen-pairs       fudgeLJ fudgeQQ\n  1             1               no              1.0     1.0\n")
        fp.write('\n')
        # Write bonded.
        self._writeBonded(fp, topology)
        # Write nonbonded.
        self._writeNonbonded(fp, topology)
        fp.write("#endif\n")

        # Write topo info.
        self._writeTopoInfo(fp, topology)

        fp.close()

class CustomTopologyOutput(AbstractTopologyOutput):

    def __init__(self, writer, inputObject):
        """
        writer: function that writes the topology; it receives as input the
        dictionary of parameter values, the inputObject and either a list of
        output files or a single output file. It should write the topology file
        to the output.

        inputObject: object with all information necessary to compose the
        topology file, except for the parameter values.  It is, typically, a
        dictionary containing data supplied in the input file for the
        corresponding $system block.

        The attribute 'output' is the object to which the topology is written.
        Typically a list of file paths. The user should know how to create the
        files they need.  This attribute must be set by an external
        AbstractTopologyOutputSetter object, so it is initialized as None.
        """
        self.writer = writer
        self.input  = inputObject
        self.output = None

    def getFiles(self):
        return self.output

    def writeToFiles(self, topology):
        import os
        # In this case, topology is a list of ParameterRefs, which we convert
        # into the appropriate dictionary.
        pardict = dict()
        for parref in topology:
            par = parref.dereference()
            ids = parref.get_full_string()
            pardict[ids] = par.get_value()
        # Make sure the directory exists.
        if type(self.output) is list:
            flist = self.output
        else:
            flist = [self.output,]
        for o_fn in self.output:
            dirname = os.path.dirname(os.path.abspath(o_fn))
            if not os.path.exists(dirname):
                os.mkdir(dirname)
        self.writer(pardict, self.input, self.output)

    # Private/open to friends:

    def _alterOutput(self, newOutput):
        self.output = newOutput


# Output Setter
# ----------------------------------------------------------------------

def incrementPrefixStandard(prefix):
    indexOfUnderscore = prefix.rfind('_')
    number            = int(prefix[indexOfUnderscore+1:])
    front             = prefix[:indexOfUnderscore]
    number           += 1
    return "{}_{}".format(front, number)

class AbstractTopologyOutputSetter(ABC):

    @abstractmethod
    def setState(self, abstractTopologyOutput, state):
        pass

    @abstractmethod
    def incrementPrefix(self):
        pass

class GromacsDummyTopologyOutputSetter(AbstractTopologyOutputSetter):

    def __init__(self, itpOutputPrefix, ext):
        self.prefix = itpOutputPrefix
        self.ext = ext

    def incrementPrefix(self):
        self.prefix = incrementPrefixStandard(self.prefix)

    def setState(self, gromacsTopologyOutput, state):
        newFile = "{}_{}.{}".format(self.prefix, state, self.ext)
        newFile = os.path.abspath(newFile)
        gromacsTopologyOutput._alterFile(newFile)


class CustomTopologyOutputSetter(AbstractTopologyOutputSetter):

    def __init__(self, prefix, getfiles):
        """prefix contains only the grid-number part, not the state part

        getfiles is a user-specified function that receives the prefix and
        returns a list with the paths of all files created for the topology.
        """
        self.prefix = prefix
        self.getfiles = getfiles

    def incrementPrefix(self):
        self.prefix = incrementPrefixStandard(self.prefix)

    def setState(self, customTopologyOutput, state):
        """Sets the correct file prefix in customTopologyOutput."""
        newPrefix = f"{self.prefix}_{state}"
        outputFiles = self.getfiles(newPrefix)
        customTopologyOutput._alterOutput(outputFiles)


# Bundle
# ----------------------------------------------------------------------

class TopologyBundle:

    def __init__(self, name, topology, topologyOutput, topologyOutputSetter):
        self.name = name
        self.topology = topology
        self.topologyOutput = topologyOutput
        self.topologyOutputSetter = topologyOutputSetter

    def getTopology(self):
        return self.topology

    def incrementPrefix(self):
        self.topologyOutputSetter.incrementPrefix()

    def writeFilesForStatepath(self, state):
        self.topologyOutputSetter.setState(self.topologyOutput, state)
        self.topologyOutput.writeToFiles(self.topology)

    def getPathsForStatepath(self, state):
        self.topologyOutputSetter.setState(self.topologyOutput, state)
        return self.topologyOutput.getFiles()

class TopologyBundleFactory:

    # customTable
    # keys = id names
    # values = (writer, getfiles) function tuple
    customTable = dict()

    @staticmethod
    def _createBundleGromacs(blockDict, itpOutputPrefix, forcefield):
        # Extract data from blockDict.
        nonbondedForcefield = forcefield[0]
        bondedForcefield    = forcefield[1]
        _name = blockDict["names"]
        try:
            itpPath = blockDict['itp']
        except KeyError:
            itpPath = blockDict['top']
        ext = os.path.splitext(itpPath)[1][1:]
        # Initialize objects.
        _inp = GromacsDummyTopologyInput(itpPath)
        _top = _inp.getTopology()
        _set = GromacsDummyTopologyOutputSetter(itpOutputPrefix, ext)
        _out = GromacsDummyTopologyOutput(itpPath, '')
        # By default, set output to state zero.
        _set.setState(_out, 0)
        # Update forcefield elements.
        _top.updateBondedForcefield(bondedForcefield)
        _top.updateNonbondedForcefield(nonbondedForcefield)
        # Create and return bundle.
        return TopologyBundle(_name, _top, _out, _set)

    @classmethod
    def _createBundleCustom(cls, customName, blockDict, outputPreffix,
                            forcefield):
        """Initialize TopoBundle for a custom system."""
        # Initialize bundle dependencies.
        print(cls.customTable)
        _writer, _gf = cls.customTable[customName]
        _set = CustomTopologyOutputSetter(outputPreffix, _gf)
        _out = CustomTopologyOutput(_writer, blockDict)
        _top = forcefield
        _name = blockDict["names"]
        return TopologyBundle(_name, _top, _out, _set)

    @classmethod
    def addCustom(cls, name, writer, getfiles):
        cls.customTable[name] = (writer, getfiles)

    @staticmethod
    def createBundle(ctrlString,
                     blockDict,
                     outPreffix,
                     forcefield):

        if ctrlString == "gromacs":
            # forcefield = (nonbondedForcefield, bondedForcefield)
            return TopologyBundleFactory._createBundleGromacs(blockDict,
                                                              outPreffix,
                                                              forcefield)
        else:
            # Custom
            # forcefield = List of GeneralParameterReference
            return TopologyBundleFactory._createBundleCustom(ctrlString,
                                                             blockDict,
                                                             outPreffix,
                                                             forcefield)


def add_custom_topology(name, writer, getfiles):
    TopologyBundleFactory.addCustom(name, writer, getfiles)
