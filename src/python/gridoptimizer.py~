
class gridOptimizer:
    """
    Class responsible for interpreting the property values and 
    """
    
    def __init__ (self):
        # dictionary indexed by properties
        self.maxSteps = 5
        self.percentCutoff = 0.25
        self.referenceValues = {}
        self.referenceTolerances = {}
        self.referenceWeights = {}
        # this is a list of TUPLES where each tuple is
        # (gridpoint_id, score)
        # this will be sorted based on score
        self.stateScores = []

    def readFromStream (self, stream):
        for line in stream:
            if (line[0] == '#'):
                continue
            elif (line.rstrip() == '$end'):
                return
            elif (line.split()[0] == 'maxsteps'):
                self.maxSteps = int(line.split()[1])
            elif (line.split()[0] == 'ncut'):
                self.percentCutoff = float(line.split()[1])
            # In all other cases, the line should satisfy the syntax
            # PROPNAME    REFERENCEVALUE     WEIGHT      TOLERANCE
            else:
                splittedLine = line.split()
                propertyName = splittedLine[0]
                self.referenceValues[propertyName] = float(splittedLine[1])
                self.referenceWeights[propertyName] = float(splittedLine[2])
                self.referenceTolerances[propertyName] = float(splittedLine[3])

    def rankScores (self):
        self.stateScores.sort(cmp=lambda x,y: cmp(x[1],y[1]))  

    def fillWithScores (self, grid):
        # clean stateScores first
        self.stateScores = []
        for gP in grid.grid_points:
            gPScore = 0.0
            weightSum = 0.0
            for prop in self.referenceTolerances.keys():
                gPValue = gP.estimated_properties[prop].value
                weightSum += self.referenceWeights[prop]
                gPScore += self.referenceWeights[prop] * ((gPValue - self.referenceValues[prop]) / self.referenceValues[prop]) ** 2
            gPScore /= weightSum
            self.stateScores.append( (gP.id, gPScore) )
        self.rankScores()

    def printToFile (self, grid, filename):
        fp = open(filename, "w")
        properties = self.referenceTolerances.keys()
        fp.write("# %3s" % "id")
        for prop in properties:
            fp.write("%12s" % prop)
            fp.write("%12s" % "err")
        fp.write("%16s\n" % "score")
        for x in self.stateScores:
            fp.write("%5d" % x[0])
            for prop in properties:
                propValue = grid[x[0]].estimated_properties[prop].value
                propErr   = grid[x[0]].estimated_properties[prop].err
                fp.write("%12.4f%12.4f" % (propValue, propErr))
            fp.write("%16.6e\n" % x[1])
        fp.close()

    def determineNextSample (self, grid):
        nTested = 0
        properties = self.referenceTolerances.keys()
        for x in self.stateScores:
            # ignore sampled
            if (x[0] in grid.get_samples_id()):
                nTested += 1
                continue
            if (nTested > self.percentCutoff * grid.linear_size):
                return -1
            for prop in properties:
                propErr = grid[x[0]].estimated_properties[prop].err
                if (propErr > self.referenceTolerances[prop]):
                    return x[0]
            nTested += 1

